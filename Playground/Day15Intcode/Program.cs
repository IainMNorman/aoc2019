using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;

namespace IntCode
{
    class Program
    {
        private static Random rng = new Random();

        static void Main(string[] args)
        {
            var program = "3,1033,1008,1033,1,1032,1005,1032,31,1008,1033,2,1032,1005,1032,58,1008,1033,3,1032,1005,1032,81,1008,1033,4,1032,1005,1032,104,99,101,0,1034,1039,1001,1036,0,1041,1001,1035,-1,1040,1008,1038,0,1043,102,-1,1043,1032,1,1037,1032,1042,1105,1,124,101,0,1034,1039,101,0,1036,1041,1001,1035,1,1040,1008,1038,0,1043,1,1037,1038,1042,1106,0,124,1001,1034,-1,1039,1008,1036,0,1041,1001,1035,0,1040,1001,1038,0,1043,1002,1037,1,1042,1105,1,124,1001,1034,1,1039,1008,1036,0,1041,102,1,1035,1040,101,0,1038,1043,1002,1037,1,1042,1006,1039,217,1006,1040,217,1008,1039,40,1032,1005,1032,217,1008,1040,40,1032,1005,1032,217,1008,1039,1,1032,1006,1032,165,1008,1040,33,1032,1006,1032,165,1101,0,2,1044,1106,0,224,2,1041,1043,1032,1006,1032,179,1101,1,0,1044,1106,0,224,1,1041,1043,1032,1006,1032,217,1,1042,1043,1032,1001,1032,-1,1032,1002,1032,39,1032,1,1032,1039,1032,101,-1,1032,1032,101,252,1032,211,1007,0,43,1044,1105,1,224,1101,0,0,1044,1106,0,224,1006,1044,247,1002,1039,1,1034,1002,1040,1,1035,102,1,1041,1036,1001,1043,0,1038,101,0,1042,1037,4,1044,1105,1,0,13,30,60,64,5,28,36,24,67,12,1,67,32,39,14,78,29,17,38,88,79,9,62,25,15,18,88,25,7,81,38,41,10,69,86,32,11,33,1,10,22,84,14,92,48,79,10,3,62,33,61,13,93,78,20,63,68,17,80,34,12,8,23,61,90,51,17,84,37,46,64,25,3,73,19,45,99,41,62,21,77,8,17,89,9,13,84,75,85,14,53,60,6,29,76,63,14,23,63,61,93,72,17,41,28,94,5,3,19,47,57,55,14,34,38,79,85,40,13,22,99,67,72,15,62,15,6,63,3,90,2,87,20,84,15,50,70,27,18,78,21,70,48,52,2,99,92,55,3,46,41,93,99,88,13,39,4,45,71,3,96,1,91,59,31,53,23,25,82,32,50,16,60,38,78,34,59,30,15,51,92,3,22,26,62,60,37,42,74,28,21,76,7,24,70,18,40,11,81,41,9,73,62,12,66,81,9,3,74,62,11,6,56,16,34,20,78,79,1,97,17,39,87,15,12,77,94,28,22,66,45,59,39,2,6,52,6,72,49,17,92,15,86,18,92,79,67,20,22,72,10,72,3,52,26,77,78,41,97,36,59,88,24,57,12,38,90,53,14,38,67,2,36,44,93,99,10,41,49,3,16,7,63,32,11,15,81,12,91,39,62,19,83,6,91,28,19,80,38,23,63,31,71,14,58,8,21,71,21,21,81,38,26,32,29,82,52,28,72,54,97,41,65,96,75,1,48,28,80,66,25,47,49,29,87,51,12,50,70,36,60,81,29,77,76,55,25,40,45,83,91,26,72,99,12,47,11,20,27,52,9,98,17,99,27,37,62,25,3,15,73,66,22,5,85,5,20,98,20,38,62,78,21,16,59,28,98,38,31,2,40,46,87,14,48,33,80,48,36,27,56,21,1,50,83,3,61,92,20,52,16,50,10,86,9,98,39,56,25,50,42,39,91,81,56,25,70,44,24,15,99,4,20,55,12,98,27,65,20,77,97,76,36,42,87,6,11,79,65,16,65,44,13,90,13,48,79,13,95,60,19,55,24,66,4,53,11,23,68,14,97,53,45,14,16,93,18,29,83,5,6,77,19,70,97,34,20,70,52,11,74,14,72,10,36,44,33,45,19,38,36,77,5,37,51,1,55,17,2,48,23,18,2,34,90,97,24,30,51,66,33,70,51,37,31,51,37,65,55,18,8,66,4,65,62,26,93,29,88,3,75,73,24,23,67,1,13,68,7,36,87,62,48,1,31,45,28,62,86,24,98,1,59,49,37,26,62,36,44,66,18,17,97,92,40,36,65,80,84,5,84,6,79,87,36,31,96,15,71,96,2,72,11,81,95,94,41,54,31,58,25,74,24,51,81,38,32,73,22,96,40,62,22,59,74,39,25,86,2,55,20,61,40,37,88,69,1,60,42,18,31,54,13,27,19,93,34,41,99,33,89,20,16,52,84,32,94,31,6,61,25,1,61,1,38,78,87,39,31,39,26,68,42,36,2,94,66,2,67,30,80,2,95,65,40,54,50,33,11,23,97,89,1,31,56,9,35,49,92,55,23,84,48,91,20,7,72,25,55,3,85,3,16,40,90,22,99,44,38,86,98,11,76,26,76,13,82,80,24,93,4,15,64,95,58,15,85,25,57,29,66,3,66,19,98,57,24,44,59,35,76,48,31,92,33,94,68,56,41,45,15,46,5,68,15,65,34,73,49,68,17,78,28,80,24,59,26,74,21,52,1,94,5,61,41,88,37,56,1,49,0,0,21,21,1,10,1,0,0,0,0,0,0";
            program = "3,1033,1008,1033,1,1032,1005,1032,31,1008,1033,2,1032,1005,1032,58,1008,1033,3,1032,1005,1032,81,1008,1033,4,1032,1005,1032,104,99,102,1,1034,1039,1002,1036,1,1041,1001,1035,-1,1040,1008,1038,0,1043,102,-1,1043,1032,1,1037,1032,1042,1105,1,124,102,1,1034,1039,101,0,1036,1041,1001,1035,1,1040,1008,1038,0,1043,1,1037,1038,1042,1105,1,124,1001,1034,-1,1039,1008,1036,0,1041,101,0,1035,1040,1001,1038,0,1043,101,0,1037,1042,1105,1,124,1001,1034,1,1039,1008,1036,0,1041,101,0,1035,1040,101,0,1038,1043,101,0,1037,1042,1006,1039,217,1006,1040,217,1008,1039,40,1032,1005,1032,217,1008,1040,40,1032,1005,1032,217,1008,1039,5,1032,1006,1032,165,1008,1040,9,1032,1006,1032,165,1102,1,2,1044,1105,1,224,2,1041,1043,1032,1006,1032,179,1102,1,1,1044,1105,1,224,1,1041,1043,1032,1006,1032,217,1,1042,1043,1032,1001,1032,-1,1032,1002,1032,39,1032,1,1032,1039,1032,101,-1,1032,1032,101,252,1032,211,1007,0,73,1044,1106,0,224,1101,0,0,1044,1106,0,224,1006,1044,247,101,0,1039,1034,1002,1040,1,1035,1002,1041,1,1036,1002,1043,1,1038,101,0,1042,1037,4,1044,1105,1,0,43,57,94,36,95,30,10,40,88,72,99,97,53,21,87,48,77,40,75,69,46,98,78,22,21,38,17,12,96,34,94,81,18,49,92,1,26,67,48,15,80,51,60,92,9,77,89,64,15,85,53,94,84,99,70,7,8,69,79,79,41,62,98,22,94,92,69,97,65,96,47,99,71,4,75,10,89,85,13,89,93,93,33,46,80,61,80,75,47,99,54,63,54,57,99,80,97,77,48,33,97,95,92,20,75,3,90,84,1,50,15,94,80,95,93,70,22,3,74,69,27,99,91,66,99,1,67,12,94,31,78,83,51,97,25,4,92,85,3,96,60,5,98,69,23,95,70,92,99,1,5,84,51,87,60,67,56,98,44,80,71,81,59,58,97,82,48,87,4,76,87,45,23,75,62,89,29,37,83,22,89,81,48,64,92,30,13,90,89,83,50,49,14,89,2,34,39,84,88,21,1,81,41,74,95,89,37,82,30,87,11,93,78,67,99,8,95,84,26,93,9,95,7,18,93,94,55,96,50,92,97,43,88,53,22,91,91,35,5,79,34,66,56,24,95,49,86,72,98,52,19,81,10,90,78,12,76,8,37,87,62,80,98,52,19,40,97,83,70,18,94,77,62,87,13,35,90,35,78,68,84,89,77,13,71,19,81,54,96,88,22,40,99,24,62,85,37,95,97,89,64,30,18,98,95,9,27,76,85,49,99,31,55,71,89,95,86,94,69,24,98,32,84,99,72,82,89,61,75,30,90,74,10,71,14,80,55,68,61,99,54,84,49,17,74,83,79,38,25,90,38,99,36,89,14,38,80,71,92,10,4,65,35,78,95,40,36,78,13,39,83,76,82,64,16,96,95,31,75,95,79,2,89,38,36,87,36,76,81,38,42,92,38,7,83,87,83,87,54,96,99,78,50,43,94,96,41,87,77,8,90,78,72,79,49,82,82,56,13,94,34,90,44,82,22,60,96,48,97,2,88,87,47,92,40,91,4,58,93,29,61,83,98,99,7,8,91,30,15,88,20,90,79,10,93,31,41,95,94,56,94,95,70,93,50,94,40,37,42,84,45,35,59,27,75,80,52,90,93,15,21,92,18,52,96,83,1,90,86,12,79,21,38,98,13,74,99,40,85,41,60,94,54,44,98,83,35,57,76,66,94,94,59,82,62,77,76,22,87,39,95,98,5,90,60,88,46,91,23,58,16,83,79,7,99,11,53,76,12,88,96,88,35,58,63,81,12,26,79,89,79,26,28,23,5,90,1,76,85,55,74,44,42,88,78,36,83,61,86,92,37,62,82,80,60,46,78,32,76,20,56,77,81,9,40,45,81,85,46,7,65,96,90,19,83,16,78,66,25,24,87,80,55,93,71,84,21,86,38,79,80,94,11,42,81,89,56,18,81,33,86,72,48,86,90,59,10,92,35,77,39,94,58,97,36,5,90,96,87,40,21,22,74,80,42,32,59,60,96,25,26,95,54,90,54,15,18,98,61,91,58,84,2,19,83,36,87,60,99,63,34,79,84,92,25,74,62,6,76,84,33,80,54,91,84,3,83,95,34,22,92,88,6,88,93,17,87,59,95,17,98,65,24,20,90,95,31,74,93,30,66,80,79,72,98,7,74,34,87,77,3,24,4,82,93,42,53,90,47,82,65,65,16,75,91,79,20,93,77,54,71,81,47,82,18,78,94,92,63,75,36,87,34,87,31,92,29,98,22,80,95,91,17,97,35,79,87,87,61,93,93,99,63,95,36,90,78,77,61,83,0,0,21,21,1,10,1,0,0,0,0,0,0";
            var disk = program
                    .Split(',')
                    .Select(x => long.Parse(x))
                    .ToArray();

            Array.Resize(ref disk, disk.Length * 2);

            var comp = new Computer(disk.ToArray(), "A");
            var dir = 0;
            var input = 0;
            var pos = new Point(0, 0);
            var newPos = new Point(0, 0);
            var destination = new Point(0, 0);
            var map = new List<MapTile>
            {
                new MapTile(pos, '.')
            };

            while (comp.Running)
            {
                //var key = Console.ReadKey();
                //switch (key.Key)
                //{
                //    case ConsoleKey.LeftArrow:
                //        input = 3;
                //        newPos = new Point(pos.X - 1, pos.Y);
                //        break;
                //    case ConsoleKey.UpArrow:
                //        input = 1;
                //        newPos = new Point(pos.X, pos.Y - 1);
                //        break;
                //    case ConsoleKey.RightArrow:
                //        input = 4;
                //        newPos = new Point(pos.X + 1, pos.Y);
                //        break;
                //    case ConsoleKey.DownArrow:
                //        input = 2;
                //        newPos = new Point(pos.X, pos.Y + 1);
                //        break;
                //    default:
                //        break;
                //}

                var adj = GetAdjacentDirsByVisitCount(map, pos);

                dir = adj.First();

                switch (dir)
                {
                    case 0: //n
                        newPos = new Point(pos.X, pos.Y - 1);
                        input = 1;
                        break;
                    case 1: //e
                        newPos = new Point(pos.X + 1, pos.Y);
                        input = 4;
                        break;
                    case 2: //s
                        newPos = new Point(pos.X, pos.Y + 1);
                        input = 2;
                        break;
                    case 3: //w
                        newPos = new Point(pos.X - 1, pos.Y);
                        input = 3;
                        break;
                    default:
                        break;
                }

                comp.Inputs.Enqueue(input);

                while (comp.Outputs.Count == 0)
                {
                    comp.RunStep();
                }

                var status = comp.Outputs.Dequeue();
                switch (status)
                {
                    case 0:
                        map.Add(new MapTile(newPos, '#'));
                        break;
                    case 1:
                        map.Add(new MapTile(newPos, '.'));
                        pos = newPos;
                        break;
                    case 2:
                        map.Add(new MapTile(newPos, '.'));
                        pos = newPos;
                        destination = pos;
                        break;
                    default:
                        break;
                }
                // DrawMaze(map, pos);               
                // detect maze complete - WTF!
                if (map.Count > 3000)
                {
                    break;
                }
            }
            DrawMaze(map, pos);
            var tidyMap = map.GroupBy(g => g.Point).Select(g => g.First());

            var shortest = GetShortestPath(tidyMap, destination);

            var time = GetTimeToFill(tidyMap, destination);

            Console.WriteLine($"{shortest}");
            Console.WriteLine($"{time}");
        }

        private static int GetShortestPath(IEnumerable<MapTile> map, Point destination)
        {
            var visited = new List<Point>();

            var q = new Queue<QNode>();

            q.Enqueue(new QNode(new Point(0, 0), 0));
            visited.Add(new Point(0, 0));

            while (q.Count > 0)
            {
                var curr = q.Peek();
                var pt = curr.Point;

                if (pt == destination)
                {
                    return curr.Distance;
                }

                q.Dequeue();

                var adjacents = new List<Point>()
                {
                    new Point(pt.X, pt.Y - 1),
                    new Point(pt.X + 1, pt.Y),
                    new Point(pt.X, pt.Y + 1),
                    new Point(pt.X - 1, pt.Y)
                };

                adjacents.ForEach(a =>
                {
                    if (map.Any(m => m.Point == a && m.Value == '.') && !visited.Any(v => v == a))
                    {
                        visited.Add(a);
                        q.Enqueue(new QNode(a, curr.Distance + 1));
                    }
                });
            }

            return -1;
        }

        private static int GetTimeToFill(IEnumerable<MapTile> map, Point start)
        {
            var visited = new List<Point>();
            var max = 0;

            var q = new Queue<QNode>();

            q.Enqueue(new QNode(start, 0));
            visited.Add(new Point(0, 0));

            while (q.Count > 0)
            {
                var curr = q.Peek();
                max = curr.Distance > max ? curr.Distance : max;
                var pt = curr.Point;

                q.Dequeue();

                var adjacents = new List<Point>()
                {
                    new Point(pt.X, pt.Y - 1),
                    new Point(pt.X + 1, pt.Y),
                    new Point(pt.X, pt.Y + 1),
                    new Point(pt.X - 1, pt.Y)
                };

                adjacents.ForEach(a =>
                {
                    if (map.Any(m => m.Point == a && m.Value == '.') && !visited.Any(v => v == a))
                    {
                        visited.Add(a);
                        q.Enqueue(new QNode(a, curr.Distance + 1));
                    }
                });
            }

            return max;
        }

        private static void DrawMaze(List<MapTile> map, Point pos)
        {
            Console.SetCursorPosition(0, 0);

            for (int y = map.Min(m => m.Point.Y); y <= map.Max(m => m.Point.Y); y++)
            {
                for (int x = map.Min(m => m.Point.X); x <= map.Max(m => m.Point.X); x++)
                {
                    if (map.Any(m => m.Point.Y == y && m.Point.X == x))
                    {
                        if (pos.X == x && pos.Y == y)
                        {
                            Console.Write('D');
                        }
                        else
                        {
                            Console.Write(map.First(m => m.Point.Y == y && m.Point.X == x).Value);
                        }

                    }
                    else
                    {
                        Console.Write(' ');
                    }
                }
                Console.Write("\n");
            }
        }

        private static List<int> GetAdjacentDirsByVisitCount(List<MapTile> map, Point pos)
        {
            var n = new Point(pos.X, pos.Y - 1);
            var e = new Point(pos.X + 1, pos.Y);
            var s = new Point(pos.X, pos.Y + 1);
            var w = new Point(pos.X - 1, pos.Y);

            var cardinalPoints = new List<Tuple<Point, int, int>>()
            {
                new Tuple<Point, int, int>(n, 0, map.Count(m => m.Point == n)),
                new Tuple<Point, int, int>(e, 1, map.Count(m => m.Point == e)),
                new Tuple<Point, int, int>(s, 2, map.Count(m => m.Point == s)),
                new Tuple<Point, int, int>(w, 3, map.Count(m => m.Point == w))
            };

            var adjDirs = new List<int>();

            cardinalPoints.OrderBy(o => o.Item3).ToList().ForEach(x =>
            {
                if ((map.FirstOrDefault(m => m.Point == x.Item1)?.Value ?? '0') != '#')
                {
                    adjDirs.Add(x.Item2);
                }
            });

            return adjDirs;
        }
    }
}